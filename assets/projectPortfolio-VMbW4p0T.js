const e=["PLANNING","ACTIVE","ON_HOLD","COMPLETED","CANCELLED"],t=t=>"string"==typeof t&&e.includes(t),n=e=>{if("number"==typeof e&&Number.isFinite(e))return e;if("string"==typeof e){const t=e.trim();if(""!==t){const e=Number(t);if(Number.isFinite(e))return e}}return null},s=s=>{const r=e.reduce((e,t)=>(e[t]=0,e),{});let i=0,o=0,a=0,c=0,u=0,l=0,d=0;const g=[],p=(new Date).getTime();s.forEach((e,s)=>{const m=(e=>{if(t(e))return e;if("string"==typeof e){const n=e.replace(/\s+/g,"_").toUpperCase();if(t(n))return n}return"PLANNING"})(e.status);r[m]=(r[m]??0)+1,"ACTIVE"===m&&(a+=1),"COMPLETED"===m&&(c+=1);const f=n(e.budget)??0;i+=f;const E=n(e.actualCost??e.spent)??0;o+=E,f>0&&E>f&&(u+=1);const N=n(e.progress);if(null!==N&&(l+=N,d+=1),e.endDate){const t=new Date(e.endDate);if(!Number.isNaN(t.getTime())){const n=Math.ceil((t.getTime()-p)/864e5),r=null!=e.id?String(e.id):`project-${s}`,i=e.name??"Untitled project",o=n<0&&"COMPLETED"!==m;"COMPLETED"!==m&&"CANCELLED"!==m&&g.push({id:r,name:i,endDate:t.toISOString(),daysRemaining:n,status:m,isOverdue:o})}}}),g.sort((e,t)=>e.daysRemaining-t.daysRemaining);const m=g.filter(e=>e.isOverdue).length;return{totalProjects:s.length,activeProjects:a,completedProjects:c,atRiskProjects:u,overdueProjects:m,pipelineValue:i,totalActualCost:o,budgetVariance:i-o,averageProgress:d>0?l/d:0,statusBreakdown:r,upcomingDeadlines:g.slice(0,5)}};export{s as c};
